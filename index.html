<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Angry Birds Fullscreen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; width: 100%; overflow: hidden; background: black;
    }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
      image-rendering: pixelated;
      /* no width/height set here, JS sets it */
    }
    /* Hide UI buttons */
    .buttons, #rovionews, #videochapter, #ingameframecontainer, #cornerframecontainer1 {
      display: none !important;
    }
  </style>
</head>
<body>
  <div id="content">
    <div id="gameDiv">
      <div id="playn-root">
        <div id="loading">
          <img src="images/loading_image_bird.png" alt="Loading..." />
        </div>
      </div>
      <div id="rovionews"></div>
      <div id="videochapter"></div>
      <div id="ingameframecontainer"></div>
      <div id="cornerframecontainer1"></div>
    </div>
  </div>

  <script src="fowl/fowl.nocache.js"></script>

  <script>
    // Scale and center the canvas
    function scaleAndCenterCanvas() {
      const canvas = document.querySelector('canvas');
      if (!canvas) return;

      const nativeWidth = canvas.width;
      const nativeHeight = canvas.height;
      if (nativeWidth === 0 || nativeHeight === 0) return false;

      const scaleX = window.innerWidth / nativeWidth;
      const scaleY = window.innerHeight / nativeHeight;
      const scale = Math.min(scaleX, scaleY);

      canvas.style.width = nativeWidth + 'px';
      canvas.style.height = nativeHeight + 'px';
      canvas.style.position = 'absolute';
      canvas.style.transformOrigin = 'left top';
      canvas.style.transform = `scale(${scale})`;

      const offsetX = (window.innerWidth - nativeWidth * scale) / 2;
      const offsetY = (window.innerHeight - nativeHeight * scale) / 2;
      canvas.style.left = offsetX + 'px';
      canvas.style.top = offsetY + 'px';

      return { scale, offsetX, offsetY };
    }

    // Convert viewport mouse coords to canvas coords
    function fixMouseCoords(e, scale, offsetX, offsetY) {
      return {
        x: (e.clientX - offsetX) / scale,
        y: (e.clientY - offsetY) / scale,
      };
    }

    // Dispatch a new mouse event with corrected coords
    function dispatchCorrectedEvent(originalEvent, canvas, fixedX, fixedY) {
      const evt = new MouseEvent(originalEvent.type, {
        bubbles: true,
        cancelable: true,
        view: window,
        detail: originalEvent.detail,
        screenX: originalEvent.screenX,
        screenY: originalEvent.screenY,
        clientX: fixedX,
        clientY: fixedY,
        ctrlKey: originalEvent.ctrlKey,
        altKey: originalEvent.altKey,
        shiftKey: originalEvent.shiftKey,
        metaKey: originalEvent.metaKey,
        button: originalEvent.button,
        buttons: originalEvent.buttons,
        relatedTarget: originalEvent.relatedTarget
      });
      canvas.dispatchEvent(evt);
    }

    // Setup scaling + fix input events by rewriting mouse events with adjusted coordinates
    function setupCanvasScalingAndInputFix() {
      const canvas = document.querySelector('canvas');
      if (!canvas) return;

      let last = { scale: 1, offsetX: 0, offsetY: 0 };

      function update() {
        const res = scaleAndCenterCanvas();
        if (res) last = res;
      }
      update();
      window.addEventListener('resize', update);

      // Listen to mouse events on window to intercept BEFORE canvas gets them
      ['mousemove', 'mousedown', 'mouseup', 'click'].forEach(eventName => {
        window.addEventListener(eventName, function(e) {
          if (!canvas) return;
          const bounds = canvas.getBoundingClientRect();
          // Check if mouse is inside canvas bounds (scaled + offset)
          if (
            e.clientX >= bounds.left && e.clientX <= bounds.right &&
            e.clientY >= bounds.top && e.clientY <= bounds.bottom
          ) {
            // Calculate fixed coordinates relative to canvas native size
            const fixedCoords = fixMouseCoords(e, last.scale, last.offsetX, last.offsetY);

            // Stop original event so it does not go to canvas with wrong coords
            e.stopImmediatePropagation();
            e.preventDefault();

            // Dispatch new event with corrected coordinates on canvas
            dispatchCorrectedEvent(e, canvas, fixedCoords.x, fixedCoords.y);
          }
        }, true); // use capture to get event first
      });
    }

    // Wait for canvas to appear then set everything up
    window.addEventListener('load', () => {
      const trySetup = () => {
        if (document.querySelector('canvas')) {
          setupCanvasScalingAndInputFix();
        } else {
          setTimeout(trySetup, 100);
        }
      };
      trySetup();
    });
  </script>
</body>
</html>
